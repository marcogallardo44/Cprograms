RATIONALNUMBER.H

// Lab 3: RationalNumber.h
// RationalNumber class definition.
#ifndef RATIONAL_NUMBER_H
#define RATIONAL_NUMBER_H

#include <iostream>
#include <iostream>
using namespace std;

class RationalNumber
{
public:
	RationalNumber(int = 0, int = 1); // default constructor
	/* Write prototype for operator + */
	RationalNumber operator+(const RationalNumber &) const;
	/*RationalNumber operator+(int) const;
	RationalNumber operator+(const int *) const;*/
	
	
	/* Write prototype for operator - */
	RationalNumber operator-(const RationalNumber &) const;
	/* Write prototype for operator * */
	RationalNumber operator*(const RationalNumber &) const;
	/* Write prototype for operator / */
	RationalNumber operator/(const RationalNumber &)const;

	// relational operators
	/* Write prototype for operator > */
	bool operator>(const RationalNumber& rhs) const;
	/* Write prototype for operator < */
	bool operator<(const RationalNumber& rhs) const;
	/* Write prototype for operator >= */
	bool operator>=(const RationalNumber& rhs) const;
	/* Write prototype for operator <= */
	bool operator<=(const RationalNumber& rhs) const;

	// equality operators
	/* Write prototype for operator == */
	bool operator==(const RationalNumber& rhs) const;
	/* Write prototype for operator != */
	bool operator!=(const RationalNumber& rhs) const;

	void printRational() const; // display rational number
private:
	int numerator; // private variable numerator
	int denominator; // private variable denominator
	void reduction(); // function for fraction reduction
}; // end class RationalNumber
#endif

------------------------------------------------------------------------

RATIONALNUMBER.CPP

// Lab 3: RationalNumber.cpp
// RationalNumber member-function definitions.
#include "stdafx.h"
#include <cstdlib>
#include <iostream>
using namespace std;

#include "RationalNumber.h"

// RationalNumber constructor sets n and d and calls reduction
/* Implement the RationalNumber constructor. Validate d first to ensure that
it is a positive number and set it to 1 if not. Call the reduction utility
function at the end */
RationalNumber::RationalNumber(int n, int d)
{
	if (d < 0)
		d = 1;
	if (d == 0)
		d = 1;
	reduction();
}
// overloaded + operator
/* Write definition for overloaded operator + */
RationalNumber RationalNumber::operator+(const RationalNumber &op2) const
{
	RationalNumber temp;
	temp.numerator = (numerator*op2.denominator) + (op2.numerator*denominator);
	temp.denominator = op2.denominator*denominator;


return temp.numerator;

} // end function operator+
/*RationalNumber RationalNumber::operator+(const RationalNumber &op2) const
{
	RationalNumber temp, temp2, temp3, a, b, c, d;

	temp = c*d;
	return temp;
} // end function operator+
RationalNumber RationalNumber::operator+(int op2) const
{
	return *this + RationalNumber(op2);
}
RationalNumber RationalNumber::operator+(const int *op2) const
{
	return *this + RationalNumber(op2);
}
void operator+(RationalNumber &op2)
{
	RationalNumber temp;
	temp.numerator = (numerator*op2.denominator) + (op2.numerator*denominator);
}*/

  // overloaded - operator
  /* Write definition for overloaded operator - */
RationalNumber RationalNumber::operator-(const RationalNumber &op2) const
{

	RationalNumber temp;
	temp.numerator = (numerator*op2.denominator) - (op2.numerator*op2.denominator);
	temp.denominator = op2.denominator*denominator;


	return temp.numerator;

}
// overloaded * operator
/* Write definition for overloaded operator * */
RationalNumber RationalNumber::operator*(const RationalNumber &op2) const
{
	RationalNumber temp;

	temp.numerator = numerator*op2.numerator;
	temp.denominator = denominator*op2.denominator;
	return temp.numerator, temp.denominator;
}
// overloaded / operator
/* Write definition for overloaded operator /. Check if the client is
attempting to divide by zero and report an error message if so */
RationalNumber RationalNumber::operator/(const RationalNumber &op2) const
{
	RationalNumber temp;
	temp.numerator = numerator*temp.denominator;
	temp.denominator = denominator*op2.numerator;
	return temp.numerator;
}

// overloaded > operator
/* Write definition for operator > */
bool RationalNumber::operator>(const RationalNumber& rhs) const
{
	if (numerator/denominator < (rhs.numerator / rhs.denominator))
		return false;
	else if (numerator / denominator >(rhs.numerator / rhs.denominator))
		return true;
}
// overloaded < operator
/* Write definition for operator < */
bool RationalNumber::operator<(const RationalNumber& rhs) const
{
		if (numerator / denominator <  (rhs.numerator / rhs.denominator))
			return true;
		else if (numerator / denominator >(rhs.numerator / rhs.denominator))
			return false;
	
}
// overloaded >= operator
/* Write definition for operator >= */
bool RationalNumber::operator>=(const RationalNumber& rhs) const
{
	if (numerator / denominator <  (rhs.numerator / rhs.denominator))
		return false;
	else if (numerator / denominator >= (rhs.numerator / rhs.denominator))
		return true;
}
// overloaded <= operator
/* Write definition for operator <= */
bool RationalNumber::operator<=(const RationalNumber& rhs) const
{
	if (numerator / denominator <= (rhs.numerator / rhs.denominator))
		return true;
	else if (numerator / denominator >  (rhs.numerator / rhs.denominator))
		return false;
}
// overloaded == operator
/* Write definition for operator == */
bool RationalNumber::operator==(const RationalNumber& rhs) const
{
	
	if (numerator / denominator != (rhs.numerator / rhs.denominator))
		return false;
	else
		return true;
}
// overloaded != operator
/* Write definition for operator != */
bool RationalNumber::operator!=(const RationalNumber& rhs) const
{
	if (numerator / denominator != (rhs.numerator / rhs.denominator))
		return true;
	else
		return false;
}
// function printRational definition
void RationalNumber::printRational() const
{
	if (numerator == 0) // print fraction as zero
		cout << numerator;
	else if (denominator == 1) // print fraction as integer
		cout << numerator;
	else
		cout << numerator << '/' << denominator;
} // end function printRational

  // function reduction definition
void RationalNumber::reduction()
{
	int largest, gcd = 1; // greatest common divisor;

	largest = (numerator > denominator) ? numerator : denominator;

	for (int loop = 2; loop <= largest; loop++)
		if (numerator % loop == 0 && denominator % loop == 0)
			gcd = loop;

	numerator /= gcd;
	denominator /= gcd;
} // end function reduction


--------------------------------------------------------------------------------------

RATIONALNUMBERTEST.CPP

// ConsoleApplication2.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <iostream>

using namespace std;
#include "RationalNumber.h"

int main()
{
	RationalNumber c(7, 3), d(3, 9), x;

	c.printRational();
	cout << " + ";
	d.printRational();
	cout << " = ";
	x = c + d; // test overloaded operators + and =
	x.printRational();

	cout << '\n';
	c.printRational();
	cout << " - ";
	d.printRational();
	cout << " = ";
	x = c - d; // test overloaded operators - and =
	x.printRational();

	cout << '\n';
	c.printRational();
	cout << " * ";
	d.printRational();
	cout << " = ";
	x = c * d; // test overloaded operators * and =
	x.printRational();

	cout << '\n';
	c.printRational();
	cout << " / ";
	d.printRational();
	cout << " = ";
	x = c / d; // test overloaded operators / and =
	x.printRational();

	cout << '\n';
	c.printRational();
	cout << " is:\n";

	// test overloaded greater than operator
	cout << ((c > d) ? " > " : " <= ");
	d.printRational();
	cout << " according to the overloaded > operator\n";

	// test overloaded less than operator
	cout << ((c < d) ? " < " : " >= ");
	d.printRational();
	cout << " according to the overloaded < operator\n";

	// test overloaded greater than or equal to operator
	cout << ((c >= d) ? " >= " : " < ");
	d.printRational();
	cout << " according to the overloaded >= operator\n";

	// test overloaded less than or equal to operator
	cout << ((c <= d) ? " <= " : " > ");
	d.printRational();
	cout << " according to the overloaded <= operator\n";

	// test overloaded equality operator
	cout << ((c == d) ? " == " : " != ");
	d.printRational();
	cout << " according to the overloaded == operator\n";

	// test overloaded inequality operator
	cout << ((c != d) ? " != " : " == ");
	d.printRational();
	cout << " according to the overloaded != operator" << endl;

	system("pause");
	return 0;
}

