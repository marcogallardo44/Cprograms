STRING.H

#include "stdafx.h"
#include <iostream>
// Lab 1: String.h
// Header file for class String. 
#ifndef STRING_H
#define STRING_H

#include <iostream> 
#include <cstring> 
#include <cassert> 
using namespace std;

class String
{
		friend ostream &operator<<( ostream &output, const String &s );
	public: 
		String( const char * const = "" ); // conversion constructor
		String( const String & ); // copy constructor
		~String(); // destructor 
		const String &operator=( const String & );
		/* Write a prototype for the operator+ member function */
		const String &operator+(const String &);
	private:
		char *sPtr; // pointer to start of string
		int length; // string length
}; // end class String

#endif

---------------------------------------------------------

STRING.CPP

// Lab 1: String.cpp
// Member-function definitions for String.cpp
#include <iostream>
#include "stdafx.h"
#include <cstring> // strcpy and strcat prototypes 
using namespace std;

#include "String.h" // String class definition 

// conversion constructor: convert a char * to String
String::String( const char * const zPtr )
{
	length = strlen( zPtr ); // compute length
	sPtr = new char[ length + 1 ]; // allocate storage 
	assert( sPtr != 0 ); // terminate if memory not allocated 
	strcpy( sPtr, zPtr ); // copy literal to object 
} // end String conversion constructor 

// copy constructor 
String::String( const String &copy )
{ 
	length = copy.length; // copy length
	sPtr = new char[ length + 1 ]; // allocate storage 
	assert( sPtr != 0 ); // ensure memory allocated
	strcpy( sPtr, copy.sPtr ); // copy string
} // end String copy constructor

  // destructor
String::~String() 
{
	delete [] sPtr; // reclaim string
} // end destructor

// overloaded = operator; avoids self assignment
const String &String::operator=( const String &right )
{
	if ( &right != this ) // avoid self assignment
		{
		     delete [] sPtr; // prevents memory leak
			 length = right.length; // new String length 
			 sPtr = new char[ length + 1 ]; // allocate memory
			 assert( sPtr != 0 ); // ensure memory allocated
			 strcpy( sPtr, right.sPtr ); // copy string
		}
	else
		cout << "Attempted assignment of a String to itself\n";
	
	return *this; // enables concatenated assignments
} // end function operator= 

// concatenate right operand and this object and store in temp object
/* Write the header for the operator+ member function */
const String &String::operator+(const String &right)
{
	/* Declare a temporary String variable named temp */
	size_t newLength = length + right.length;
	char *tempPtr = new char[newLength + 1];
	/* Set temp’s length to be the sum of the two argument Strings’ lengthes */
	strcpy(tempPtr, sPtr);
	/* Allocate memory for temp.length + 1 chars and assign the pointer to temp.sPtr */
	
	assert( sPtr != 0 ); // terminate if memory not allocated
	/* Copy the left String argument’s contents into temp.sPtr */
	strcpy(tempPtr + length, right.sPtr);
	
	/* Write a call to strcat to concatenate the string in right 
	 onto the end of the string in temp */ 
	delete[] sPtr;
	sPtr = tempPtr;
	length = newLength;

	/* Return the temporary String */
	return *this;
} // end function operator+

// overloaded output operator 
ostream & operator<<( ostream &output, const String &s )
{
	output << s.sPtr;
	return output; // enables concatenation
} // end function operator<<

-------------------------------------------------------------------------------------
STRINGTEST.CPP



#include "stdafx.h"
#include <iostream>

#include "String.h" 
using namespace std;

int main()
{
	String string1, string2("The date is");
	String string3(" August 1, 1993");

	// test overloaded operators 
	cout << "string1 = string2 + string3\n";
	/* Write a statement to concatenate string2 and string3,
	and assign the result to string1 */
	string1 = string2 + string3;
	cout << "\"" << string1 << "\" = \"" << string2 << "\" + \""
		<< string3 << "\"" << endl;



	system("pause");
	return 0;
}

